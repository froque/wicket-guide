<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>9 Under the hood of the request processing 6.x</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <ul>
        <li>
            <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                <a href="../guide/index.html" class="button">Table of contents</a>

                <div id="nav-summary-childs" style="display:none;">
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter1.html"><strong>1</strong><span>Introduction</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/howToSource.html"><strong>2</strong><span>How to use the example code</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter2.html"><strong>3</strong><span>Why should I learn Wicket?</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter3.html"><strong>4</strong><span>Wicket says &ldquo;Hello world!&rdquo;</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter4.html"><strong>5</strong><span>Wicket as page layout manager</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter5.html"><strong>6</strong><span>Keeping control over HTML</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter6.html"><strong>7</strong><span>Components lifecycle</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter7.html"><strong>8</strong><span>Page versioning and caching</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter8.html"><strong>9</strong><span>Under the hood of the request processing</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter9.html"><strong>10</strong><span>Wicket Links and URL generation</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter10.html"><strong>11</strong><span>Wicket models and forms</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter11.html"><strong>12</strong><span>Wicket forms in detail</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter12.html"><strong>13</strong><span>Displaying multiple items with repeaters</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter13.html"><strong>14</strong><span>Internationalization with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter14.html"><strong>15</strong><span>Resource management with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter15.html"><strong>16</strong><span>An example of integration with JavaScript</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter16.html"><strong>17</strong><span>Wicket advanced topics</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter17.html"><strong>18</strong><span>Working with AJAX</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter18.html"><strong>19</strong><span>Integration with enterprise containers</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter19.html"><strong>20</strong><span>Security with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter20.html"><strong>21</strong><span>Test Driven Development with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter21.html"><strong>22</strong><span>Test Driven Development with Wicket and Spring</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter22.html"><strong>23</strong><span>Wicket Best Practices</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter23.html"><strong>24</strong><span>Working with Maven (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter24.html"><strong>25</strong><span>Project WicketStuff (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter25.html"><strong>26</strong><span>Lost In Redirection With Apache Wicket (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter26.html"><strong>27</strong><span>Contributing to this guide (Appendix)</span></a>
                    </div>
                    
                </div>
            </div>
        </li>
        <li class="separator selected">
            <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
        </li>
    </ul>
</div>
<div id="header">
    <div class="images clearfix">
        
        <span id="logo"><a href="/" target="_blank"><img height="80px" src="http://wicket.apache.org/guide/img/apache-wicket.png"/></a></span>
        
        
        <span id="sponsor"><a href="http://www.apache.org/" target="_blank"><img height="60px" src="http://wicket.apache.org/guide/img/asf_logo.gif"/></a></span>
        
    </div>
    <p>Free Online Guide for Apache Wicket framework</p>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/chapter7.html">&lt;&lt; <strong>8</strong><span>Page versioning and caching</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/chapter9.html"><strong>10</strong><span>Wicket Links and URL generation</span> >></a></div>
                


                <div class="project">
                    <h1>9 Under the hood of the request processing - Reference Documentation</h1>

                    <p><strong>Authors:</strong> Andrea Del Bene, Carsten Hufe, Christian Kroemer, Daniel Bartl, Paul Bor»ô</p>

                    <p><strong>Version:</strong> 6.x</p>

                    
                </div>

                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter8_1"><strong>9.1</strong><span>Class Application and request processing</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter8_2"><strong>9.2</strong><span>Request and Response classes</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter8_3"><strong>9.3</strong><span>The &ldquo;director&rdquo; of request processing - RequestCycle</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter8_4"><strong>9.4</strong><span>Session Class</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter8_5"><strong>9.5</strong><span>Summary</span></a>
                    </div>
                    
                </div>
                

                

<h1 id="chapter8">9 Under the hood of the request processing</h1>
Although Wicket was born to provide a reliable and comprehensive object oriented abstraction for web development, sometimes we might need to work directly with ‚Äúraw‚Äù web entities such as user session, web request, query parameters, and so on. For example this is necessary if we want to store an arbitrary parameter in the user session.<p class="paragraph"/>Wicket provides wrapper classes that allow us to easily access to web entities without the burden of using the low-level APIs of Java Servlet Specification. However it will always be possible to access standard classes (like HttpSession, HttpServletRequest, etc...) that lay under our Wicket application.
This chapter will introduce these wrapper classes and it will explain how Wicket uses them to handle the web requests initiated by the user's browser.


<h2 id="chapter8_1">9.1 Class Application and request processing</h2>
<p class="paragraph"/>Beside configuring and initializing our application, the Application class is responsible for creating the internal entities used by Wicket to process a request. These entities are instances of the following classes: RequestCycle, Request, Response and Session.<p class="paragraph"/>The next paragraphs will illustrate each of these classes, explaining how they are involved into request processing.


<h2 id="chapter8_2">9.2 Request and Response classes</h2>
<p class="paragraph"/>The Request and Response classes are located in package org.apache.wicket.request and they provide an abstraction of the concrete request and response used by our web application.<p class="paragraph"/>Both classes are declared as abstract but if our application class inherits from WebApplication it will use their sub classes ServletWebRequest and ServletWebResponse, both of them located inside the package org.apache.wicket.protocol.http.servlet.ServletWebRequest and ServletWebResponse wrap respectively a HttpServletRequest and a HttpServletResponse object. If we need to access to these low-level objects we can call Request's method getContainerRequest() and Response's method getContainer Response().


<h2 id="chapter8_3">9.3 The ‚Äúdirector‚Äù of request processing - RequestCycle</h2>
<p class="paragraph"/>Class org.apache.wicket.request.cycle.RequestCycle is the entity in charge of serving a web request. Our application class creates a new RequestCycle on every request with its method createRequestCycle(request, response).<p class="paragraph"/>Method createRequestCycle is declared as final, so we can't override it to return a custom subclass of RequestCycle. Instead, we must build a request cycle provider implementing interface org.apache.wicket.IRequestCycleProvider, and then we must tell our application class to use it via the setRequestCycleProvider method.<p class="paragraph"/>The current running request cycle can be retrieved at any time by calling its static method RequestCycle.get(). Strictly speaking this method returns the request cycle associated with the current (or local) thread, which is the thread that is serving the current request. A similar get() method is also implemented in classes org.apache.wicket.Application (as we have seen in paragraph 2.2.2) and org.apache.wicket.Session in order to get the application and the session in use by the current thread.<p class="paragraph"/><blockquote class="note">
The implementation of the get method takes advantage of the standard class java.lang.ThreadLocal. See its JavaDoc for an introduction to local-thread variables.
</blockquote><p class="paragraph"/>Class org.apache.wicket.Component provides the getRequestCycle() method which is a convenience method that internally invokes RequestCycle.get():<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> RequestCycle getRequestCycle() &#123;
	<span class="java&#45;keyword">return</span> RequestCycle.get();
&#125;</pre></div><p class="paragraph"/><h3>RequestCycle and request processing</h3><p class="paragraph"/><blockquote class="note">
This paragraph will provide just the basic informations about what happens behind the scenes of request processing. When you work with Wicket it's unlikely to have a need for customizing this process, so we won't cover this topic in detail.
</blockquote><p class="paragraph"/>In order to process a request, RequestCycle delegates the task to another entity which implements interface org.apache.wicket.request.IRequestHandler. There are different implementations of this interface, each suited for a particular type of requested resource (a page to render, an AJAX request, an URL to an external page, etc.).<p class="paragraph"/>To resolve the right handler for a given HTTP request, the RequestCycle uses a set of objects implementing the org.apache.wicket.request.IRequestMapper interface. The mapping interface defines the getCompatibilityScore(Request request) method which returns a score indicating how compatible the request mapper is for the current request. RequestCycle will choose the mapper with the highest score and it will call its mapRequest(Request request) method to get the proper handler for the given request. Once RequestCycle has resolved a request handler, it invokes its method respond(IRequestCycle requestCycle) to start request processing.<p class="paragraph"/>The following sequence diagram recaps how a request handler is resolved by the RequestCycle:<p class="paragraph"/><img border="0" class="center" src="../img/request-cycle-handler.png"></img><p class="paragraph"/>Developers can create additional implementations of IRequestMapper and add them to their application via the mount(IRequestMapper mapper) method of the WebApplication class. In paragraph 8.6 we will see how Wicket uses this method to add built-in mappers for mounted pages.<p class="paragraph"/><h3>Generating URL with the urlFor and mapUrlFor methods</h3><p class="paragraph"/>The RequestCycle is also responsible for generating the URL value (as CharSequence) for the following entities:
<ul class="star">
<li>a page class, via the urlFor(Class&#60;C&#62; pageClass, PageParameters parameters) method</li>
<li>an IRequestHandler via the urlFor(IRequestHandler handler) method</li>
<li>a ResourceReference via the urlFor(ResourceReference reference, PageParameters params) method (resource entities will be introduced in chapter 13).</li>
</ul><p class="paragraph"/>The overloaded urlFor method from above also has a corresponding version that returns an instance of org.apache.wicket.request.Url instead of a CharSequence. This version has the prefix 'map' in its name (i.e. it has mapUrlFor as full name).<p class="paragraph"/><h3>Method setResponsePage</h3><p class="paragraph"/>The RequestCycle class contains the implementation of the setResponsePage method we use to redirect a user to a specific page (see paragraph 2.4). The namesake method of class org.apache.wicket.Component is just a convenience method that internally invokes the actual implementation on current request cycle:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void setResponsePage(<span class="java&#45;keyword">final</span> Page page) &#123;
	getRequestCycle().setResponsePage(page);
&#125;</pre></div><p class="paragraph"/><h3>RequestCycle's hook methods and listeners</h3><p class="paragraph"/>The RequestCycle comes with some hook methods which can be overridden to perform custom actions when request handling reaches a specific stage. These methods are:
<ul class="star">
<li><strong class="bold">onBeginRequest():</strong> called when the RequestCycle is about to start handling the request.</li>
<li><strong class="bold">onEndRequest():</strong> called when the RequestCycle has finished to handle the request</li>
<li><strong class="bold">onDetach():</strong> called after the request handling has completed and the RequestCycle is about to be detached from its thread. The default implementation of this method invokes detach() on the current session (the Session class will be shortly discussed in paragraph 7.4).</li>
</ul><p class="paragraph"/>Methods onBeforeRequest and onEndRequest can be used if we need to execute custom actions before and after business code is executed, such as opening a Hibernate/JPA session and closing it when code has terminated.<p class="paragraph"/>A more flexible way to interact with the request processing is to use the listener interface org.apache.wicket.request.cycle.IRequestCycleListener. In addition to the three methods already seen for RequestCycle, this interface offers further hooks into request processing:
<ul class="star">
<li><strong class="bold">onBeginRequest(RequestCycle cycle):</strong> (see the description above)</li>
<li><strong class="bold">onEndRequest(RequestCycle cycle):</strong> (see the description above)</li>
<li><strong class="bold">onDetach(RequestCycle cycle):</strong> (see the description above)</li>
<li><strong class="bold">onRequestHandlerResolved(RequestCycle cycle, IRequestHandler handler):</strong> called when an IRequestHandler has been resolved.</li>
<li><strong class="bold">onRequestHandlerScheduled(RequestCycle cycle, IRequestHandler handler):</strong> called when an IRequestHandler has been scheduled for execution.</li>
<li><strong class="bold">onRequestHandlerExecuted(RequestCycle cycle, IRequestHandler handler):</strong> called when an IRequestHandler has been executed.</li>
<li><strong class="bold">onException(RequestCycle cycle, Exception ex):</strong> called when an exception has been thrown during request processing.</li>
<li><strong class="bold">onExceptionRequestHandlerResolved(RequestCycle rc, IRequestHandler rh, Exception ex):</strong> called when an IRequestHandler has been resolved and will be used to handle an exception.</li>
<li><strong class="bold">onUrlMapped(RequestCycle cycle, IRequestHandler handler, Url url):</strong> called when an URL has been generated for an IRequestHandler object.</li>
</ul><p class="paragraph"/>To use the request cycle listeners we must add them to our application which in turn will pass them to the new RequestCycle's instances created with createRequestCycle method:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init() &#123;<p class="paragraph"/>	<span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>	IRequestCycleListener myListener;
	//listener initialization&#8230;
	getRequestCycleListeners().add(myListener)		
&#125;</pre></div><p class="paragraph"/>The getRequestCycleListeners method returns an instance of class org.apache.wicket.request.cycle.RequestCycleListenerCollection. This class is a sort of typed collection for IRequestCycleListener and it also implements the <a href="http://en.wikipedia.org/wiki/Composite_pattern" target="blank">Composite pattern</a> .<p class="paragraph"/>


<h2 id="chapter8_4">9.4 Session Class</h2>
<p class="paragraph"/>In Wicket we use class org.apache.wicket.Session to handle session-relative informations such as client informations, session attributes, session-level cache (seen in paragraph 6.2.4), etc...<p class="paragraph"/>In addition, we know from paragraph 6.1 that Wicket creates a user session to store versions of stateful pages. Similarly to what happens with RequestCycle, the new Session's instances are generated by the Application class with the newSession(Request request, Response response) method. This method is not declared as final, hence it can be overridden if we need to use a custom implementation of the Session class.<p class="paragraph"/>By default if our custom application class is a subclass of WebApplication, method newSession will return an instance of class org.apache.wicket.protocol.http.WebSession. As we have mentioned talking about RequestCycle, also class Session provides a static get() method which returns the session associated to the current thread.<p class="paragraph"/><h3>Session and listeners</h3><p class="paragraph"/>Similar to the RequestCycle, class org.apache.wicket.Session also offers support for listener entities. With Session these entities must implement the callback interface org.apache.wicket.ISessionListener which exposes only the onCreated(Session session) method. As you might guess from its name, this method is called when a new session is created. Session listeners must be added to our application using a typed collection, just like we have done before with request cycle listeners:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()&#123;<p class="paragraph"/>	<span class="java&#45;keyword">super</span>.init();<p class="paragraph"/>	//listener initialization&#8230;
	ISessionListener myListener;
	//add a custom session listener
	getSessionListeners().add(myListener)<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>Handling session attributes</h3><p class="paragraph"/>The Session class handles session attributes in much the same way as the standard interface javax.servlet.http.HttpSession. The following methods are provided to create, read and remove session attributes:
<ul class="star">
<li><strong class="bold">setAttribute(String name, Serializable value):</strong> creates an attribute identified by the given name. If the session already contains an attribute with the same name, the new value will replace the existing one. The value must be a serializable object.</li>
<li><strong class="bold">getAttribute(String name):</strong> returns the value of the attribute identified by the given name, or null if the name does not correspond to any attribute.</li>
<li><strong class="bold">removeAttribute(String name):</strong> removes the attribute identified by the given name.</li>
</ul><p class="paragraph"/>By default class WebSession will use the underlying http session to store attributes. Wicket will automatically add a prefix to the name of the attributes. This prefix is returned by the WebApplication's method getSessionAttributePrefix().<p class="paragraph"/><h3>Accessing to the HTTP session</h3><p class="paragraph"/>If for any reason we need to directly access to the underlying HttpSession object, we can retrieve it from the current request with the following code:<p class="paragraph"/><div class="code"><pre>HttpSession session = ((ServletWebRequest)RequestCycle.get()
		.getRequest()).getContainerRequest().getSession();</pre></div><p class="paragraph"/>Using the raw session object might be necessary if we have to set a session attribute with a particular name without the prefix added by Wicket. Let's say for example that we are working with Tomcat as web server. One of the administrative tools provided by Tomcat is a page listing all the active user sessions of a given web application:<p class="paragraph"/><img border="0" class="center" src="../img/tomcat-admin-sessions.png"></img><p class="paragraph"/>Tomcat allows us to set the values that will be displayed in columns ‚ÄúGuessed locale‚Äù and ‚ÄúGuessed User name‚Äù. One possible way to do this is to use session attributes named ‚ÄúLocale‚Äù and ‚ÄúuserName‚Äù but we can't create them via Wicket's Session class because they would not have exactly the name required by Tomcat. Instead, we must use the raw HttpSession and set our attributes on it:<p class="paragraph"/><div class="code"><pre>HttpSession session = ((ServletWebRequest)RequestCycle.get().
		getRequest()).getContainerRequest().getSession();<p class="paragraph"/>session.setAttribute(<span class="java&#45;quote">"Locale"</span>, <span class="java&#45;quote">"ENGLISH"</span>);
session.setAttribute(<span class="java&#45;quote">"userName"</span>, <span class="java&#45;quote">"Mr BadGuy"</span>);</pre></div><p class="paragraph"/><h3>Temporary and permanent sessions</h3><p class="paragraph"/>Wicket doesn't need to store data into user session as long as the user visits only stateless pages. Nonetheless, even under these conditions, a temporary session object is created to process each request but it is discarded at the end of the current request. To know if the current session is temporary, we can use the isTemporary() method:<p class="paragraph"/><div class="code"><pre>Session.get().isTemporary();</pre></div><p class="paragraph"/>If a session is not temporary (i.e. it is permanent), it's identified by an unique id which can be read calling the getId() method. This value will be null if the session is temporary.<p class="paragraph"/>Although Wicket is able to automatically recognize when it needs to replace a temporary session with a permanent one, sometimes we may need to manually control this process to make our initially temporary session permanent.<p class="paragraph"/>To illustrate this possible scenario let's consider project BindSessionExample where we have a stateless home page which sets a session attribute inside its constructor and then it redirects the user to another page which displays with a label the session attribute previously created. The code of the two pages is as follows:<p class="paragraph"/>Home page:
<div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;
    <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;
    	Session.get().setAttribute(<span class="java&#45;quote">"username"</span>, <span class="java&#45;quote">"tommy"</span>);
	Session.get().bind();<p class="paragraph"/>	setResponsePage(DisplaySessionParameter.class);
    &#125;   
&#125;</pre></div><p class="paragraph"/>Target page:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class DisplaySessionParameter <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> DisplaySessionParameter() &#123;
	   <span class="java&#45;keyword">super</span>();
	   add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"username"</span>, (<span class="java&#45;object">String</span>) Session.get().getAttribute(<span class="java&#45;quote">"username"</span>)));
	&#125;
&#125;</pre></div><p class="paragraph"/>Again, we kept page logic very simple to not over-bloat the example with unnecessary code. In the snippet above we have also bolded Session's bind() method which converts temporary session into a permanent one. If the home page has not invoked this method, the session with its attribute would have been discarded at the end of the request and the page DisplaySessionParameter would have displayed an empty value in its label.<p class="paragraph"/><h3>Discarding session data</h3><p class="paragraph"/>Once a user has finished using our web application, she must be able to log out and clean any session data. To be sure that a permanent session will be discarded at the end of the current request, class Session provides the invalidate() method. If we want to immediately invalidate a given session without waiting for the current request to complete, we can invoke the invalidateNow() method.<p class="paragraph"/><blockquote class="warning">
Remember that invalidateNow() will immediately remove any instance of components (and pages) from the session, meaning that once we have called this method we won't be able to work with them for the rest of the request process.
</blockquote><p class="paragraph"/><h3>Storing arbitrary objects with metadata</h3><p class="paragraph"/>JavaServer Pages Specification1 defines 4 scopes in which a page can create and access a variable. These scopes are:
<ul class="star">
<li><strong class="bold">request:</strong> variables declared in this scope can be seen only by pages processing the same request. The lifespan of these variables is (at most) equal to the one of the related request. They are discarded when the full response has been generated or when the request is forwarded somewhere else.</li>
<li><strong class="bold">page:</strong> variables declared in this scope can be seen only by the page that has created them.</li>
<li><strong class="bold">session:</strong> variables in session scope can be created and accessed by every page used in the same session where they are defined.</li>
<li><strong class="bold">application:</strong> this is the widest scope. Variables declared in this scope can be used by any page of a given web application.</li>
</ul><p class="paragraph"/>Although Wicket doesn't implement the JSP Specification (it is rather an alternative to it), it offers a feature called metadata which resembles scoped variables but is much more powerful. Metadata is quite similar to a Java Map in that it stores pairs of key-value objects where the key must be unique. In Wicket each of the following classes has its own metadata store: RequestCycle, Session, Application and Component.<p class="paragraph"/>The key used for metadata is an instance of class org.apache.wicket.MetaDataKey&#60;T&#62;. To put an arbitrary object into metadata we must use the setMetaData method which takes two parameters as input: the key used to store the value and the value itself. If we are using metadata with classes Session or Component, data object must be serializable because Wicket serializes both session and component instances. This constraint is not applied to metadata of classes Application and RequestCycle which can contain a generic object. In any case, the type of data object must be compatible with the type parameter T specified by the key.<p class="paragraph"/>To retrieve a previously inserted object we must use the getMetaData(MetaDataKey&#60;T&#62; key) method. In the following example we set a java.sql.Connection object in the application's metadata so it can be used by any page of the application:<p class="paragraph"/>Application class code:
<div class="code"><pre><span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> MetaDataApp <span class="java&#45;keyword">extends</span> WebApplication&#123;
	//Do some stuff&#8230;
	/&#42;&#42;
	&#42; Metadata key definition
	&#42;/
	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">static</span> MetaDataKey&#60;Connection&#62; connectionKey = <span class="java&#45;keyword">new</span> MetaDataKey&#60;Connection&#62; ()&#123;&#125;;<p class="paragraph"/>	/&#42;&#42;
	 &#42; Application's initialization
	 &#42;/
	@Override
	<span class="java&#45;keyword">public</span> void init()&#123;<p class="paragraph"/>		<span class="java&#45;keyword">super</span>.init();
		Connection connection;
		//connection initialization&#8230;
		setMetaData(connectionKey, connection);
		//Do some other stuff..<p class="paragraph"/>	&#125;
&#125;</pre></div><p class="paragraph"/>Code to get the object from the metadata:<p class="paragraph"/><div class="code"><pre>Connection connection = Application.get().getMetaData(MetaDataApp.connectionKey);</pre></div><p class="paragraph"/>Since MetaDataKey&#60;T&#62; class is declared as abstract, we must implement it with a subclass or with an anonymous class (like we did in the example above).



<h2 id="chapter8_5">9.5 Summary</h2>
<p class="paragraph"/>In this chapter we had a look at how Wicket internally handles a web request. Even if most of the time  we won't need to customize this internal process, knowing how it works is essential to use the framework at 100%.<p class="paragraph"/>Entities like Application and Session will come in handy again when we will tackle the topic of security in chapter 18.


                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/chapter7.html">&lt;&lt; <strong>8</strong><span>Page versioning and caching</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/chapter9.html"><strong>10</strong><span>Wicket Links and URL generation</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
Copyright &copy; 2013 ‚Äî <a href="http://www.apache.org/" target="_blank">The Apache Software Foundation</a>

    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
